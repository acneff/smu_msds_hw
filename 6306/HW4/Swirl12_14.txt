> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new, call yourself something unique.

What shall I call you? Alec

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 12

  |                                                                                                                                              |   0%

| Whenever you're working with a new dataset, the first thing you should do is look at it! What is the format of the data? What are the dimensions?
| What are the variable names? How are the variables stored? Are there missing data? Are there any flaws in the data?

...

  |======                                                                                                                                        |   4%
| This lesson will teach you how to answer these questions and more using R's built-in functions. We'll be using a dataset constructed from the United
| States Department of Agriculture's PLANTS Database (http://plants.usda.gov/adv_search.html).

...

  |===========                                                                                                                                   |   8%
| I've stored the data for you in a variable called plants. Type ls() to list the variables in your workspace, among which should be plants.

> ls()
[1] "plants"

| That's correct!

  |=================                                                                                                                             |  12%
| Let's begin by checking the class of the plants variable with class(plants). This will give us a clue as to the overall structure of the data.

> class(plants)
[1] "data.frame"

| That's a job well done!

  |=======================                                                                                                                       |  16%
| It's very common for data to be stored in a data frame. It is the default class for data read into R using functions like read.csv() and
| read.table(), which you'll learn about in another lesson.

...

  |============================                                                                                                                  |  20%
| Since the dataset is stored in a data frame, we know it is rectangular. In other words, it has two dimensions (rows and columns) and fits neatly into
| a table or spreadsheet. Use dim(plants) to see exactly how many rows and columns we're dealing with.

> dim(plants)
[1] 5166   10

| Your dedication is inspiring!

  |==================================                                                                                                            |  24%
| The first number you see (5166) is the number of rows (observations) and the second number (10) is the number of columns (variables).

...

  |========================================                                                                                                      |  28%
| You can also use nrow(plants) to see only the number of rows. Try it out.

> nrow(plants)
[1] 5166

| Excellent job!

  |=============================================                                                                                                 |  32%
| ... And ncol(plants) to see only the number of columns.

> ncol(plants)
[1] 10

| Keep up the great work!

  |===================================================                                                                                           |  36%
| If you are curious as to how much space the dataset is occupying in memory, you can use object.size(plants).

> object.size(plants)
644232 bytes

| That's correct!

  |=========================================================                                                                                     |  40%
| Now that we have a sense of the shape and size of the dataset, let's get a feel for what's inside. names(plants) will return a character vector of
| column (i.e. variable) names. Give it a shot.

> names(plants)
 [1] "Scientific_Name"      "Duration"             "Active_Growth_Period" "Foliage_Color"        "pH_Min"               "pH_Max"              
 [7] "Precip_Min"           "Precip_Max"           "Shade_Tolerance"      "Temp_Min_F"          

| All that hard work is paying off!

  |==============================================================                                                                                |  44%
| We've applied fairly descriptive variable names to this dataset, but that won't always be the case. A logical next step is to peek at the actual
| data. However, our dataset contains over 5000 observations (rows), so it's impractical to view the whole thing all at once.

...

  |====================================================================                                                                          |  48%
| The head() function allows you to preview the top of the dataset. Give it a try with only one argument.

> head(plants)
               Scientific_Name          Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance Temp_Min_F
1                  Abelmoschus              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
2       Abelmoschus esculentus Annual, Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
3                        Abies              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
4               Abies balsamea         Perennial    Spring and Summer         Green      4      6         13         60        Tolerant        -43
5 Abies balsamea var. balsamea         Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
6                     Abutilon              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA

| Excellent work!

  |==========================================================================                                                                    |  52%
| Take a minute to look through and understand the output above. Each row is labeled with the observation number and each column with the variable
| name. Your screen is probably not wide enough to view all 10 columns side-by-side, in which case R displays as many columns as it can on each line
| before continuing on the next.

...

  |================================================================================                                                              |  56%
| By default, head() shows you the first six rows of the data. You can alter this behavior by passing as a second argument the number of rows you'd
| like to view. Use head() to preview the first 10 rows of plants.

> head(plants, n=10L)
                     Scientific_Name          Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance
1                        Abelmoschus              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
2             Abelmoschus esculentus Annual, Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
3                              Abies              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
4                     Abies balsamea         Perennial    Spring and Summer         Green      4    6.0         13         60        Tolerant
5       Abies balsamea var. balsamea         Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
6                           Abutilon              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
7               Abutilon theophrasti            Annual                 <NA>          <NA>     NA     NA         NA         NA            <NA>
8                             Acacia              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
9                  Acacia constricta         Perennial    Spring and Summer         Green      7    8.5          4         20      Intolerant
10 Acacia constricta var. constricta         Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
   Temp_Min_F
1          NA
2          NA
3          NA
4         -43
5          NA
6          NA
7          NA
8          NA
9         -13
10         NA

| Keep trying! Or, type info() for more options.

| head(plants, 10) will show you the first 10 rows of the dataset.

> head(plants, 10)
                     Scientific_Name          Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance
1                        Abelmoschus              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
2             Abelmoschus esculentus Annual, Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
3                              Abies              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
4                     Abies balsamea         Perennial    Spring and Summer         Green      4    6.0         13         60        Tolerant
5       Abies balsamea var. balsamea         Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
6                           Abutilon              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
7               Abutilon theophrasti            Annual                 <NA>          <NA>     NA     NA         NA         NA            <NA>
8                             Acacia              <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>
9                  Acacia constricta         Perennial    Spring and Summer         Green      7    8.5          4         20      Intolerant
10 Acacia constricta var. constricta         Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>
   Temp_Min_F
1          NA
2          NA
3          NA
4         -43
5          NA
6          NA
7          NA
8          NA
9         -13
10         NA

| All that hard work is paying off!

  |=====================================================================================                                                         |  60%
| The same applies for using tail() to preview the end of the dataset. Use tail() to view the last 15 rows.

> tail(plants,15)
                      Scientific_Name  Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance Temp_Min_F
5152                          Zizania      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5153                 Zizania aquatica    Annual               Spring         Green    6.4    7.4         30         50      Intolerant         32
5154   Zizania aquatica var. aquatica    Annual                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5155                Zizania palustris    Annual                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5156 Zizania palustris var. palustris    Annual                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5157                      Zizaniopsis      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5158             Zizaniopsis miliacea Perennial    Spring and Summer         Green    4.3    9.0         35         70      Intolerant         12
5159                            Zizia      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5160                     Zizia aptera Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5161                      Zizia aurea Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5162                 Zizia trifoliata Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5163                          Zostera      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5164                   Zostera marina Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5165                           Zoysia      <NA>                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA
5166                  Zoysia japonica Perennial                 <NA>          <NA>     NA     NA         NA         NA            <NA>         NA

| You're the best!

  |===========================================================================================                                                   |  64%
| After previewing the top and bottom of the data, you probably noticed lots of NAs, which are R's placeholders for missing values. Use summary(plants)
| to get a better feel for how each variable is distributed and how much of the dataset is missing.

> summary(plants)
                     Scientific_Name              Duration              Active_Growth_Period      Foliage_Color      pH_Min          pH_Max      
 Abelmoschus                 :   1   Perennial        :3031   Spring and Summer   : 447      Dark Green  :  82   Min.   :3.000   Min.   : 5.100  
 Abelmoschus esculentus      :   1   Annual           : 682   Spring              : 144      Gray-Green  :  25   1st Qu.:4.500   1st Qu.: 7.000  
 Abies                       :   1   Annual, Perennial: 179   Spring, Summer, Fall:  95      Green       : 692   Median :5.000   Median : 7.300  
 Abies balsamea              :   1   Annual, Biennial :  95   Summer              :  92      Red         :   4   Mean   :4.997   Mean   : 7.344  
 Abies balsamea var. balsamea:   1   Biennial         :  57   Summer and Fall     :  24      White-Gray  :   9   3rd Qu.:5.500   3rd Qu.: 7.800  
 Abutilon                    :   1   (Other)          :  92   (Other)             :  30      Yellow-Green:  20   Max.   :7.000   Max.   :10.000  
 (Other)                     :5160   NA's             :1030   NA's                :4334      NA's        :4334   NA's   :4327    NA's   :4327    
   Precip_Min      Precip_Max         Shade_Tolerance   Temp_Min_F    
 Min.   : 4.00   Min.   : 16.00   Intermediate: 242   Min.   :-79.00  
 1st Qu.:16.75   1st Qu.: 55.00   Intolerant  : 349   1st Qu.:-38.00  
 Median :28.00   Median : 60.00   Tolerant    : 246   Median :-33.00  
 Mean   :25.57   Mean   : 58.73   NA's        :4329   Mean   :-22.53  
 3rd Qu.:32.00   3rd Qu.: 60.00                       3rd Qu.:-18.00  
 Max.   :60.00   Max.   :200.00                       Max.   : 52.00  
 NA's   :4338    NA's   :4338                         NA's   :4328    

| Excellent job!

  |=================================================================================================                                             |  68%
| summary() provides different output for each variable, depending on its class. For numeric data such as Precip_Min, summary() displays the minimum,
| 1st quartile, median, mean, 3rd quartile, and maximum. These values help us understand how the data are distributed.

...

  |======================================================================================================                                        |  72%
| For categorical variables (called 'factor' variables in R), summary() displays the number of times each value (or 'level') occurs in the data. For
| example, each value of Scientific_Name only appears once, since it is unique to a specific plant. In contrast, the summary for Duration (also a
| factor variable) tells us that our dataset contains 3031 Perennial plants, 682 Annual plants, etc.

...

  |============================================================================================================                                  |  76%
| You can see that R truncated the summary for Active_Growth_Period by including a catch-all category called 'Other'. Since it is a categorical/factor
| variable, we can see how many times each value actually occurs in the data with table(plants$Active_Growth_Period).

> table(plants$Active_Growth_Period)

Fall, Winter and Spring                  Spring         Spring and Fall       Spring and Summer    Spring, Summer, Fall                  Summer 
                     15                     144                      10                     447                      95                      92 
        Summer and Fall              Year Round 
                     24                       5 

| You are really on a roll!

  |==================================================================================================================                            |  80%
| Each of the functions we've introduced so far has its place in helping you to better understand the structure of your data. However, we've left the
| best for last....

...

  |=======================================================================================================================                       |  84%
| Perhaps the most useful and concise function for understanding the *str*ucture of your data is str(). Give it a try now.

> str(plants)
'data.frame':	5166 obs. of  10 variables:
 $ Scientific_Name     : Factor w/ 5166 levels "Abelmoschus",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ Duration            : Factor w/ 8 levels "Annual","Annual, Biennial",..: NA 4 NA 7 7 NA 1 NA 7 7 ...
 $ Active_Growth_Period: Factor w/ 8 levels "Fall, Winter and Spring",..: NA NA NA 4 NA NA NA NA 4 NA ...
 $ Foliage_Color       : Factor w/ 6 levels "Dark Green","Gray-Green",..: NA NA NA 3 NA NA NA NA 3 NA ...
 $ pH_Min              : num  NA NA NA 4 NA NA NA NA 7 NA ...
 $ pH_Max              : num  NA NA NA 6 NA NA NA NA 8.5 NA ...
 $ Precip_Min          : int  NA NA NA 13 NA NA NA NA 4 NA ...
 $ Precip_Max          : int  NA NA NA 60 NA NA NA NA 20 NA ...
 $ Shade_Tolerance     : Factor w/ 3 levels "Intermediate",..: NA NA NA 3 NA NA NA NA 2 NA ...
 $ Temp_Min_F          : int  NA NA NA -43 NA NA NA NA -13 NA ...

| Perseverance, that's the answer.

  |=============================================================================================================================                 |  88%
| The beauty of str() is that it combines many of the features of the other functions you've already seen, all in a concise and readable format. At the
| very top, it tells us that the class of plants is 'data.frame' and that it has 5166 observations and 10 variables. It then gives us the name and
| class of each variable, as well as a preview of its contents.

...

  |===================================================================================================================================           |  92%
| str() is actually a very general function that you can use on most objects in R. Any time you want to understand the structure of something (a
| dataset, function, etc.), str() is a good place to start.

...

  |========================================================================================================================================      |  96%
| In this lesson, you learned how to get a feel for the structure and contents of a new dataset using a collection of simple and useful functions.
| Taking the time to do this upfront can save you time and frustration later on in your analysis.

...

  |==============================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| All that hard work is paying off!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 13

  |                                                                                                                                              |   0%

| One of the great advantages of using a statistical programming language like R is its vast collection of tools for simulating random numbers.

...

  |====                                                                                                                                          |   3%
| This lesson assumes familiarity with a few common probability distributions, but these topics will only be discussed with respect to random number
| generation. Even if you have no prior experience with these concepts, you should be able to complete the lesson and understand the main ideas.

...

  |=========                                                                                                                                     |   6%
| The first function we'll use to generate random numbers is sample(). Use ?sample to pull up the documentation.

> ?sample

| Keep working like that and you'll get there!

  |=============                                                                                                                                 |   9%
| Let's simulate rolling four six-sided dice: sample(1:6, 4, replace = TRUE).

> sample(1:6,4,replace = TRUE)
[1] 5 4 3 2

| All that hard work is paying off!

  |=================                                                                                                                             |  12%
| Now repeat the command to see how your result differs. (The probability of rolling the exact same result is (1/6)^4 = 0.00077, which is pretty
| small!)

> sample(1:6,4,replace = TRUE)
[1] 5 4 2 6

| That's a job well done!

  |======================                                                                                                                        |  15%
| sample(1:6, 4, replace = TRUE) instructs R to randomly select four numbers between 1 and 6, WITH replacement. Sampling with replacement simply means
| that each number is "replaced" after it is selected, so that the same number can show up more than once. This is what we want here, since what you
| roll on one die shouldn't affect what you roll on any of the others.

...

  |==========================                                                                                                                    |  18%
| Now sample 10 numbers between 1 and 20, WITHOUT replacement. To sample without replacement, simply leave off the 'replace' argument.

> sample(1:10)
 [1]  3  7 10  1  8  4  5  6  9  2

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Type sample(1:20, 10) to sample 10 numbers between 1 and 20, without replacement.

> sample(1:20,10)
 [1]  7 15 13  6 12  3 17  1 11 19

| That's a job well done!

  |==============================                                                                                                                |  21%
| Since the last command sampled without replacement, no number appears more than once in the output.

...

  |==================================                                                                                                            |  24%
| LETTERS is a predefined variable in R containing a vector of all 26 letters of the English alphabet. Take a look at it now.

> LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"

| Perseverance, that's the answer.

  |=======================================                                                                                                       |  27%
| The sample() function can also be used to permute, or rearrange, the elements of a vector. For example, try sample(LETTERS) to permute all 26 letters
| of the English alphabet.

> sample(LETTERS)
 [1] "T" "E" "F" "I" "B" "C" "X" "P" "A" "M" "W" "V" "S" "Y" "L" "Z" "G" "D" "K" "Q" "U" "H" "J" "N" "R" "O"

| That's a job well done!

  |===========================================                                                                                                   |  30%
| This is identical to taking a sample of size 26 from LETTERS, without replacement. When the 'size' argument to sample() is not specified, R takes a
| sample equal in size to the vector from which you are sampling.

...

  |===============================================                                                                                               |  33%
| Now, suppose we want to simulate 100 flips of an unfair two-sided coin. This particular coin has a 0.3 probability of landing 'tails' and a 0.7
| probability of landing 'heads'.

...

  |====================================================                                                                                          |  36%
| Let the value 0 represent tails and the value 1 represent heads. Use sample() to draw a sample of size 100 from the vector c(0,1), with replacement.
| Since the coin is unfair, we must attach specific probabilities to the values 0 (tails) and 1 (heads) with a fourth argument, prob = c(0.3, 0.7).
| Assign the result to a new variable called flips.

> sample(c(0,1),100,prob = c(0.3,0.7))
Error in sample.int(length(x), size, replace, prob) : 
  cannot take a sample larger than the population when 'replace = FALSE'
> sample(c(0,1),100,replace = TRUE,prob = c(0.3,0.7))
  [1] 1 1 0 1 0 0 1 0 0 1 1 0 1 0 0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 0 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 1 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 1 0 1 1 0 1 0 0 1 1 1 1
 [74] 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 1 1 0 1 1 0 1

| Not quite, but you're learning! Try again. Or, type info() for more options.

| The following command will produce 100 flips of an unfair coin and assign the result: flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3,
| 0.7))

> flips<-sample(c(0,1),100,replace = TRUE,prob = c(0.3,0.7))

| Perseverance, that's the answer.

  |========================================================                                                                                      |  39%
| View the contents of the flips variable.

> flips
  [1] 1 1 0 1 1 0 0 1 0 1 0 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 1 1 0 0
 [74] 0 1 0 0 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 0 0 1

| Excellent work!

  |============================================================                                                                                  |  42%
| Since we set the probability of landing heads on any given flip to be 0.7, we'd expect approximately 70 of our coin flips to have the value 1. Count
| the actual number of 1s contained in flips using the sum() function.

> sum(flips==1)
[1] 72

| One more time. You can do it! Or, type info() for more options.

| sum(flips) will add up all the 1s and 0s, giving you the total number of 1s in flips.

> sum(flips)
[1] 72

| You got it right!

  |=================================================================                                                                             |  45%
| A coin flip is a binary outcome (0 or 1) and we are performing 100 independent trials (coin flips), so we can use rbinom() to simulate a binomial
| random variable. Pull up the documentation for rbinom() using ?rbinom.

> ?rbinom

| That's a job well done!

  |=====================================================================                                                                         |  48%
| Each probability distribution in R has an r*** function (for "random"), a d*** function (for "density"), a p*** (for "probability"), and q*** (for
| "quantile"). We are most interested in the r*** functions in this lesson, but I encourage you to explore the others on your own.

...

  |=========================================================================                                                                     |  52%
| A binomial random variable represents the number of 'successes' (heads) in a given number of independent 'trials' (coin flips). Therefore, we can
| generate a single random variable that represents the number of heads in 100 flips of our unfair coin using rbinom(1, size = 100, prob = 0.7). Note
| that you only specify the probability of 'success' (heads) and NOT the probability of 'failure' (tails). Try it now.

> rbinom(1,size = 100,prob = 0.7)
[1] 70

| All that hard work is paying off!

  |=============================================================================                                                                 |  55%
| Equivalently, if we want to see all of the 0s and 1s, we can request 100 observations, each of size 1, with success probability of 0.7. Give it a
| try, assigning the result to a new variable called flips2.

> flips2<-rbinom(100,size = 1,prob = 0.7)

| That's a job well done!

  |==================================================================================                                                            |  58%
| View the contents of flips2.

> flips2
  [1] 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 1 0 0 0 0 1 0 0 1 1 1 0 1 1 1 1 0 1 1 1 0 1 0 1 1 0 0 0 1 0 0 1 1 1 1 1 1
 [74] 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 0 0

| Perseverance, that's the answer.

  |======================================================================================                                                        |  61%
| Now use sum() to count the number of 1s (heads) in flips2. It should be close to 70!

> sum(flips2)
[1] 63

| Great job!

  |==========================================================================================                                                    |  64%
| Similar to rbinom(), we can use R to simulate random numbers from many other probability distributions. Pull up the documentation for rnorm() now.

> ?rnorm

| You got it right!

  |===============================================================================================                                               |  67%
| The standard normal distribution has mean 0 and standard deviation 1. As you can see under the 'Usage' section in the documentation, the default
| values for the 'mean' and 'sd' arguments to rnorm() are 0 and 1, respectively. Thus, rnorm(10) will generate 10 random numbers from a standard normal
| distribution. Give it a try.

> 
> rnorm(10)
 [1]  1.3141599 -0.9718156  1.0241039 -0.5711459 -1.6336688 -0.3201313  1.2920703 -0.4058738  1.0562511 -0.2342970

| Nice work!

  |===================================================================================================                                           |  70%
| Now do the same, except with a mean of 100 and a standard deviation of 25.

> rnorm(mean = 100,sd = 25)
Error in rnorm(mean = 100, sd = 25) : 
  argument "n" is missing, with no default
> rnorm(10,mean = 100,sd = 25)
 [1] 153.54734 110.45198 115.70327  92.05395  95.42756 119.41417  98.89628  79.26429  50.67906  48.50903

| You are doing so well!

  |=======================================================================================================                                       |  73%
| Finally, what if we want to simulate 100 *groups* of random numbers, each containing 5 values generated from a Poisson distribution with mean 10?
| Let's start with one group of 5 numbers, then I'll show you how to repeat the operation 100 times in a convenient and compact way.

...

  |============================================================================================================                                  |  76%
| Generate 5 random values from a Poisson distribution with mean 10. Check out the documentation for rpois() if you need help.

> rpois(5,10)
[1]  9 10  3 15 12

| You are doing so well!

  |================================================================================================================                              |  79%
| Now use replicate(100, rpois(5, 10)) to perform this operation 100 times. Store the result in a new variable called my_pois.

> replicate(100, rpois(5,10))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]
[1,]    9    7   10    6   10   10   11   10    6    10    11     5     8    12    16    15    15    16    10     7     8     6    10    12    12     5
[2,]   17   15   17    7   13   12    8   12    9     7     5    11     7    10    10    14     8     6    10    10    15     6    10     7    12    16
[3,]   14   12   14    7   15   10   15   11    6     6    10    11    15    11     8    11    13    15     8     8    19     8    21    10    12     7
[4,]    5    9   10    8   11    9   12    9    7    10    12     9     2    11    12     4     9     5    13    10     6     6    10    10    10     9
[5,]    4   11   11    9    8    7   11   10   13    10     6    10    12     9     9    12    11    11    11     4    10    12    13    13    11    10
     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
[1,]     9     6     6    14     9    12    10    10    11     8    12     6    12    24     7    17     7    10    12     9    12    13    15    14
[2,]    13     8     8     9    12    11     7    16    13    12     8    13     8     6    14    15    11     9    13    13    13    11     7    11
[3,]    13     4     7     8    12    12    12     3     6    13     8    12    11     4    21     5    10     8    16     5    11     9     8     9
[4,]     9    11     8     6    10    12     6    10     9    10     9    12     7    12    12     6     9     9     8    11    19    11    11     8
[5,]     9     9     7    12     8    14    11     7     6    11     7    10     2    15    11    11    15    15    11    12    12    11     9    17
     [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62] [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74]
[1,]    13     6     5    13    14     7     5    13     9    12    11    19     8     9    16    14     9     9    10    12     4     5     5     4
[2,]     5    10    10    11    10     8    14     3    12     9    10    10    12     8     9     9    11    11     6    10     9     7     9    14
[3,]     6    11     8    11    11     6    11     7    11    11    11    14    13    11    12     7    10     6    10     6     7    18     9     6
[4,]     4    10    12    13     9     8     9     7     9    11    12    13    11    11     9     7     7     8    10     6    10     7    12     9
[5,]     9    15    13     7     5    11     9    13    12    17     9     7     8     9     9    13     7    16    10     9     9     6    12    12
     [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86] [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98]
[1,]    11    11    10     8     8     9    14    10     4    11    11    12    10    13    15    15     7    10    10     7    15    11     3     9
[2,]    12     8    13     9    15     9     5     8     9     9    10    12     8    15     6     9    10    10    10    14     8    13     9     5
[3,]    12    13     8     9     7     7    13    10    12    15    10    12    13    13     5     9    10    10     8    11    15    10    10     9
[4,]    10    10    11     9     9    13    10     9    12     9    11     4     9    12     6     4     5    11    13     5     9     9    16    12
[5,]    13    12    10    14     7     9    11    17    10    14    13     6     6     9    11     7     9     6     4    11    12    12     5     8
     [,99] [,100]
[1,]     9      4
[2,]     8      8
[3,]    11      6
[4,]    12     12
[5,]     7     11

| Not quite, but you're learning! Try again. Or, type info() for more options.

| my_pois <- replicate(100, rpois(5, 10)) will repeat the operation 100 times and store the result.

> my_pois<-replicate(100, rpois(5,10))

| You are quite good my friend!

  |====================================================================================================================                          |  82%
| Take a look at the contents of my_pois.

> my_pois
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]
[1,]    9    7    7    9    9    6    8    7    8    12    15     6    11     7    11     7    14     7    15    10     9     8    10     9    16    17
[2,]    7   10   10   17   14   12    4    7   19    10    14    10    14    16     9    12     5    12     7    11    10     9    12    10    14     7
[3,]    9    8   11    7    9    8    7   10    6    11     7     7    16     8    10     7     9     9    10    10    12     5    11     8     9    10
[4,]    5   21   14   10   11   15   10   11    6     6    11     5    11     7     6    13     8     9    16    13    14    14     5    11    14     5
[5,]    9   11   10    7    8    9   10    9   11     6     9    17    13     7     8     7    14     8    11     8     8    13    10     8    14    10
     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
[1,]     9    10    14     9    15     9     7     3     5     6    10     7    14    13     7    12     8    10     6     7    10    11     5     8
[2,]    13     6     9     9    10    11     9    11    13    16     5    10     9    11     9    10    10    14    10    10     6    10     8     2
[3,]     7    16     7     8     7    12     8     9    12    10    13     6    10     9    15    12    11    17    11     8    10     9     4    15
[4,]     7    15     6    11     9     7     6    16     9    11    11    13     9    11    15    17    10    10     9     7     9     9    14    14
[5,]     6     8    13     8     5    12     4    13     7     4    12    12    10     8     7    13    10     6    13     8    15    10    10    11
     [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62] [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74]
[1,]    14    12     7     7    12     8     7    11     7    10     6    12    12    11     3    11     9     4     8    16    10    13     9     7
[2,]     9     5    11     9    13     7     7     6    10    10    12    15    21     9    11     9    10    13    14     8    11     8    13    10
[3,]    15    11    12    12    12    10    11    15    11     7     8     8     8    20    13     8    14    11     4    10    10    13    11    11
[4,]     6    12    14     9    13    16     6    10     8    12    11     8     8    21     7     9    10     7     7     5     8    10    13    12
[5,]     7     7     9    11    11     8    11    10     8     6    11     8    14     6    15    16    14    12    11    12     6    10     5    11
     [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86] [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98]
[1,]    10     7     8    11    10     6     3    18    11     7    12    12     8     7    11    10    11    11     8    10    11     6     7     5
[2,]     8     8     7    10     6     9    12     7    14    11    11    10    13     3    12     8     7    10    12    14     7    13     7    10
[3,]     9    14    12    14    12     9     8     8    13    12     7    10    13     9    15     6     7    13    16    13    15    11    14     9
[4,]     6    13     7    11    14    11     7    12    11     7     9    15    14     8    16    17     9     7     8     8     9     8    10     5
[5,]    11     6    12    14    15    14     8     9     7    10     8     5     9     8    13    12     3    12    10     7    10    12    12     9
     [,99] [,100]
[1,]    10      8
[2,]     7      5
[3,]     6      9
[4,]     6      3
[5,]     9      6

| That's the answer I was looking for.

  |========================================================================================================================                      |  85%
| replicate() created a matrix, each column of which contains 5 random numbers generated from a Poisson distribution with mean 10. Now we can find the
| mean of each column in my_pois using the colMeans() function. Store the result in a variable called cm.

> cm<-colMeans(my_pois)

| Excellent work!

  |=============================================================================================================================                 |  88%
| And let's take a look at the distribution of our column means by plotting a histogram with hist(cm).

> hist(cm)

| That's a job well done!

  |=================================================================================================================================             |  91%
| Looks like our column means are almost normally distributed, right? That's the Central Limit Theorem at work, but that's a lesson for another day!

...

  |=====================================================================================================================================         |  94%
| All of the standard probability distributions are built into R, including exponential (rexp()), chi-squared (rchisq()), gamma (rgamma()), .... Well,
| you see the pattern.

...

  |==========================================================================================================================================    |  97%
| Simulation is practically a field of its own and we've only skimmed the surface of what's possible. I encourage you to explore these and other
| functions further on your own.

...

  |==============================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Excellent job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 14

  |                                                                                                                                              |   0%

| R has a special way of representing dates and times, which can be helpful if you're working with data that show how something changes over time (i.e.
| time-series data) or if your data contain some other temporal information, like dates of birth.

...

  |====                                                                                                                                          |   3%
| Dates are represented by the 'Date' class and times are represented by the 'POSIXct' and 'POSIXlt' classes. Internally, dates are stored as the
| number of days since 1970-01-01 and times are stored as either the number of seconds since 1970-01-01 (for 'POSIXct') or a list of seconds, minutes,
| hours, etc. (for 'POSIXlt').

...

  |========                                                                                                                                      |   6%
| Let's start by using d1 <- Sys.Date() to get the current date and store it in the variable d1. (That's the letter 'd' and the number 1.)

> d1<-Sys.Date()

| That's correct!

  |============                                                                                                                                  |   8%
| Use the class() function to confirm d1 is a Date object.

> class(d1)
[1] "Date"

| Nice work!

  |================                                                                                                                              |  11%
| We can use the unclass() function to see what d1 looks like internally. Try it out.

> unclass(d1)
[1] 17681

| All that practice is paying off!

  |====================                                                                                                                          |  14%
| That's the exact number of days since 1970-01-01!

...

  |========================                                                                                                                      |  17%
| However, if you print d1 to the console, you'll get today's date -- YEAR-MONTH-DAY. Give it a try.

> d1
[1] "2018-05-30"

| Excellent job!

  |============================                                                                                                                  |  19%
| What if we need to reference a date prior to 1970-01-01? Create a variable d2 containing as.Date("1969-01-01").

> d2<-as.Date("1969-01-01")

| Great job!

  |================================                                                                                                              |  22%
| Now use unclass() again to see what d2 looks like internally.

> unclass(d2)
[1] -365

| You nailed it! Good job!

  |====================================                                                                                                          |  25%
| As you may have anticipated, you get a negative number. In this case, it's -365, since 1969-01-01 is exactly one calendar year (i.e. 365 days) BEFORE
| 1970-01-01.

...

  |=======================================                                                                                                       |  28%
| Now, let's take a look at how R stores times. You can access the current date and time using the Sys.time() function with no arguments. Do this and
| store the result in a variable called t1.

> t1<-Sys.time()

| Nice work!

  |===========================================                                                                                                   |  31%
| View the contents of t1.

> t1
[1] "2018-05-30 18:18:21 CDT"

| You are quite good my friend!

  |===============================================                                                                                               |  33%
| And check the class() of t1.

> class(t1)
[1] "POSIXct" "POSIXt" 

| You got it right!

  |===================================================                                                                                           |  36%
| As mentioned earlier, POSIXct is just one of two ways that R represents time information. (You can ignore the second value above, POSIXt, which just
| functions as a common language between POSIXct and POSIXlt.) Use unclass() to see what t1 looks like internally -- the (large) number of seconds
| since the beginning of 1970.

> unclass(t1)
[1] 1527722302

| Perseverance, that's the answer.

  |=======================================================                                                                                       |  39%
| By default, Sys.time() returns an object of class POSIXct, but we can coerce the result to POSIXlt with as.POSIXlt(Sys.time()). Give it a try and
| store the result in t2.

> t2<-as.POSIXlt(Sys.time())

| You are really on a roll!

  |===========================================================                                                                                   |  42%
| Check the class of t2.

> class(t2)
[1] "POSIXlt" "POSIXt" 

| You are really on a roll!

  |===============================================================                                                                               |  44%
| Now view its contents.

> t2
[1] "2018-05-30 18:20:29 CDT"

| Your dedication is inspiring!

  |===================================================================                                                                           |  47%
| The printed format of t2 is identical to that of t1. Now unclass() t2 to see how it is different internally.

> unclass(t2)
$sec
[1] 29.57968

$min
[1] 20

$hour
[1] 18

$mday
[1] 30

$mon
[1] 4

$year
[1] 118

$wday
[1] 3

$yday
[1] 149

$isdst
[1] 1

$zone
[1] "CDT"

$gmtoff
[1] -18000

attr(,"tzone")
[1] ""    "CST" "CDT"

| Excellent work!

  |=======================================================================                                                                       |  50%
| t2, like all POSIXlt objects, is just a list of values that make up the date and time. Use str(unclass(t2)) to have a more compact view.

> str(unclass(t2))
List of 11
 $ sec   : num 29.6
 $ min   : int 20
 $ hour  : int 18
 $ mday  : int 30
 $ mon   : int 4
 $ year  : int 118
 $ wday  : int 3
 $ yday  : int 149
 $ isdst : int 1
 $ zone  : chr "CDT"
 $ gmtoff: int -18000
 - attr(*, "tzone")= chr [1:3] "" "CST" "CDT"

| All that practice is paying off!

  |===========================================================================                                                                   |  53%
| If, for example, we want just the minutes from the time stored in t2, we can access them with t2$min. Give it a try.

> t2$min
[1] 20

| You are doing so well!

  |===============================================================================                                                               |  56%
| Now that we have explored all three types of date and time objects, let's look at a few functions that extract useful information from any of these
| objects -- weekdays(), months(), and quarters().

...

  |===================================================================================                                                           |  58%
| The weekdays() function will return the day of week from any date or time object. Try it out on d1, which is the Date object that contains today's
| date.

> weekdays(d1)
[1] "Wednesday"

| Your dedication is inspiring!

  |=======================================================================================                                                       |  61%
| The months() function also works on any date or time object. Try it on t1, which is the POSIXct object that contains the current time (well, it was
| the current time when you created it).

> months(t1)
[1] "May"

| You got it right!

  |===========================================================================================                                                   |  64%
| The quarters() function returns the quarter of the year (Q1-Q4) from any date or time object. Try it on t2, which is the POSIXlt object that contains
| the time at which you created it.

> quarters(t2)
[1] "Q2"

| You are quite good my friend!

  |===============================================================================================                                               |  67%
| Often, the dates and times in a dataset will be in a format that R does not recognize. The strptime() function can be helpful in this situation.

...

  |===================================================================================================                                           |  69%
| strptime() converts character vectors to POSIXlt. In that sense, it is similar to as.POSIXlt(), except that the input doesn't have to be in a
| particular format (YYYY-MM-DD).

...

  |=======================================================================================================                                       |  72%
| To see how it works, store the following character string in a variable called t3: "October 17, 1986 08:24" (with the quotes).

> t3<-"October 17, 1986 08:24"

| You nailed it! Good job!

  |==========================================================================================================                                    |  75%
| Now, use strptime(t3, "%B %d, %Y %H:%M") to help R convert our date/time object to a format that it understands. Assign the result to a new variable
| called t4. (You should pull up the documentation for strptime() if you'd like to know more about how it works.)

> strptime(t3, "%B %d, %Y %H:%M")
[1] "1986-10-17 08:24:00 CDT"

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| t4 <- strptime(t3, "%B %d, %Y %H:%M") will convert our date/time object to a format that R understands.

> t4<-strptime(t3, "%B %d, %Y %H:%M")

| You are amazing!

  |==============================================================================================================                                |  78%
| Print the contents of t4.

> t4
[1] "1986-10-17 08:24:00 CDT"

| You nailed it! Good job!

  |==================================================================================================================                            |  81%
| That's the format we've come to expect. Now, let's check its class().

> class(t4)
[1] "POSIXlt" "POSIXt" 

| That's the answer I was looking for.

  |======================================================================================================================                        |  83%
| Finally, there are a number of operations that you can perform on dates and times, including arithmetic operations (+ and -) and comparisons (<, ==,
| etc.)

...

  |==========================================================================================================================                    |  86%
| The variable t1 contains the time at which you created it (recall you used Sys.time()). Confirm that some time has passed since you created t1 by
| using the 'greater than' operator to compare it to the current time: Sys.time() > t1

> Sys.time()>t1
[1] TRUE

| You are quite good my friend!

  |==============================================================================================================================                |  89%
| So we know that some time has passed, but how much? Try subtracting t1 from the current time using Sys.time() - t1. Don't forget the parentheses at
| the end of Sys.time(), since it is a function.

> Sys.time()-t1
Time difference of 30.64684 mins

| Great job!

  |==================================================================================================================================            |  92%
| The same line of thinking applies to addition and the other comparison operators. If you want more control over the units when finding the above
| difference in times, you can use difftime(), which allows you to specify a 'units' parameter.

...

  |======================================================================================================================================        |  94%
| Use difftime(Sys.time(), t1, units = 'days') to find the amount of time in DAYS that has passed since you created t1.

> difftime(Sys.time(),t1,units = "days")
Time difference of 0.02180835 days

| You're the best!

  |==========================================================================================================================================    |  97%
| In this lesson, you learned how to work with dates and times in R. While it is important to understand the basics, if you find yourself working with
| dates and times often, you may want to check out the lubridate package by Hadley Wickham.

...

  |==============================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| You're the best!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!